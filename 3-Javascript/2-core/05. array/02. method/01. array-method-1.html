<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>array method</title>
</head>

<body>
    <!-- <script>
        // delete 요소 하나만 지우고 배열 자리는 남아있음.
        let arr = ["I", "go", "home"];
        delete arr[1]; // "go"를 삭제합니다.
        alert(arr[1]); // undefined
        // delete를 써서 요소를 지우고 난 후 배열 , arr = ["I",  , "home"];
        alert(arr.length); // 3
    </script> -->

    <!-- <script>
        //splic : 요소를 지우고 사이에 요소를 추가함.
        let arr = ["I", "study", "JavaScript", "right", "now"];

        let removed = arr.splice(0, 2, "We", "love");  // 0부터 2개의 요소를 지우고 뒤를 추가
        console.log(removed); // 삭제된 요소를 보여줌
        console.log(arr);

        arr.splice(1, 0, "really", "do"); // 1번째 요소 뒤에 0개 요소를 삭제하고 "really", "do" 를 넣는다.
        console.log(arr);

        arr.splice(-2, 0, "and", "JAVA"); // 음수는 뒤부터 역순으로 -1,-2,-3
        console.log(arr);

        arr.splice(-2);
        console.log(arr);
    </script> -->

    <!-- <script>
        // slice  arr.slic([start],[end]);
        // start부터 end 전까지 요소를 새로운 배열에 복사 (end는 포함 X)
        let arr = ["a", "b", "c", "d", "e", "f", "g", "h"];

        console.log(arr.slice(1, 4));  //1-3 ['b','c','d'] 함수를 따로 넘기지 않고 배열의 일부만 호출
        console.log(arr.slice(-5));  // 뒤에서 5번째부터 끝까지 복사
    </script> -->

    <!-- <script>
        // concat : arr.concat([1], 2, ...) 원래 배열에 (안에) 요소 더하기, 
        // 배열이와도 되고 숫자가 와도됨. 갯수 제한 없음
        // [배열].concat(+, +, +, +)

        let arr = [1, 2];

        let arrplus = {
            home: "sweet",
            my: "seet home",
            [Symbol.isConcatSpreadable]: false, //이런 특수 프로퍼티 있으면 객체를 배열처럼 취급
            length: 2 //글쎄
        }

        console.log(arr.concat([3, 4]));
        console.log(arr.concat([3, 4], [5, 6]));
        console.log(arr.concat([3, 4], 5, 6));
        console.log(arr.concat([3, 4], "ana", null, [100, 1], "99"));
        console.log(arr.concat(["song", "bird"], ["ana", null], [[100, 1], "99"]));
        console.log(arr.concat([3, 4], 5, 6, arrplus)); // [1, 2, 3, 4, 5, 6,{home: "sweet", my: "seet home"}]
        alert(arr.concat([3, 4], 5, 6, arrplus)) //1,2,3,4,5,6,[object Object]
        console.log(arr.concat(arrplus));
    </script> -->
    <!-- 
    <script>
        // forEach : arr.forEach(function(item(요소), index(순서번호), array(배열)) {} );
        let arr = ["Bilbo", "Gandalf", "Nazgul"];

        ["Bilbo", "Gandalf", "Nazgul"].forEach(alert);  // 각 하나씩 얼럿

        arr.forEach((item, index, array) => {
            console.log(`${item} is at index ${index} in ${array}`);
        });
    </script> -->

    <!-- <script>
        // 배열 탐색
        // indexOf:  arr.indexOf(item, from)
        // from부터 시작해 item 을 찾아서 보여줌(배열요소), NaN 못찾음, 없는 값은 (-1) 반환

        // lastIndexPf:  arr.lastIndexOf(item, from)
        // from부터 시작해 item 을 찾아서 보여줌 , 거꾸로 탐색 시작

        // includes:  arr.includes(item, from)
        // from부터 시작해 item 을 찾아서 보여줌, 찾은 결과는(true/false), NaN 찾을수있음

        let arr = [9, "start", true, null, 9, NaN, "", 100, 86, 9];

        console.log(arr.indexOf(9)); // 0 번째 배열에 있다.
        console.log(arr.indexOf(9, 3));  // 9를 3번째 배열부터 찾아라  =  4번째 배열에 있다.
        console.log(arr.indexOf(true));  // 2번째 배열에 있다.
        console.log(arr.indexOf(100, 9)); //100을 9번째 배열부터 찾아라 =  -1 : 없다
        console.log(arr.indexOf(""));  // 6번째 배열에 있다.

        console.log(arr.includes(9)); //true
        console.log(arr.includes(100, 8)); // flase, 8번째 배열 이후로 100 없음
        console.log(arr.includes(100, 3)); // true, 3번 배열 뒤로 100있음
        // 차이점
        console.log(arr.indexOf(NaN)); // -1 , === 엄격비교, NaN 엔 동작하지 않음
        console.log(arr.includes(NaN)); // true, == 비교, NaN 에 동작함.
    </script> -->

    <!-- <script>
        // map : 작업 함수의 결과를 새로운 배열 형태로 출력

        let arr = [1, 2, 3, 4, 5, 6, 7, 8];
        let result = arr.map(item => item < 7);
        console.log(result); //[true, true, true, true, true, true, false, false]

        console.log("=======================");

        let name = ["HarryPotter", "Hermione", "Loan", "Dumbledore"];

        let lengthsOfName = name.map(item => item.length);
        console.log(lengthsOfName); //[11, 8, 4, 10]

        let upper = name.map(item => item.toUpperCase());
        console.log(upper); // ["HARRYPOTTER", "HERMIONE", "LOAN", "DUMBLEDORE"]
    </script> -->

    <script>

    </script>
</body>

</html>

<!-- 
    splice: 요소 삭제,  배열 splice(시작위치, 삭제할 개수) / 배열splice(시작위치) : 위치부터 마지막 요소까지 삭제
 -->